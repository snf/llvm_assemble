#[allow(non_upper_case_globals)]
#[allow(non_camel_case_types)]
mod extern_def {
    /* automatically generated by rust-bindgen */

    pub type ptrdiff_t = ::libc::c_long;
    pub type size_t = ::libc::c_ulong;
    pub type wchar_t = ::libc::c_int;
    pub type byte = ::libc::c_uchar;
    pub type Enum_Arch = ::libc::c_uint;
    pub const x86: ::libc::c_uint = 0;
    pub const x86_64: ::libc::c_uint = 1;
    pub const mips: ::libc::c_uint = 2;
    pub const arm: ::libc::c_uint = 3;
    pub const arm64: ::libc::c_uint = 4;
    pub const thumb: ::libc::c_uint = 5;
    pub const ppc32: ::libc::c_uint = 6;
    #[link(name = "assemble")]
    extern "C" {
        pub fn assemble(arch: Enum_Arch, instructions: *const ::libc::c_char,
                        out: *mut byte, out_len: *mut size_t) -> ::libc::c_int;
    }
}

#[allow(non_camel_case_types)]
pub enum Arch {
    X86,
    X86_64,
    Mips,
    Arm,
    Arm64,
    Thumb,
    PPC32
}

impl Arch {
    pub fn to_c(self) -> u32 {
        match self {
            Arch::X86 => extern_def::x86,
            Arch::X86_64 => extern_def::x86_64,
            Arch::Mips => extern_def::mips,
            Arch::Arm => extern_def::arm,
            Arch::Arm64 => extern_def::arm64,
            Arch::Thumb => extern_def::thumb,
            Arch::PPC32 => extern_def::ppc32
        }
    }
}

pub fn assemble(arch: Arch, input: &str) -> Option<Vec<u8>> {
    use std::ffi::CString;
    use std::slice;
    use libc;

    let e_arch = arch.to_c();
    let ins = CString::new(input).unwrap();

    unsafe {
        let mut out_len = 0x100;
        let out_arr: *mut u8 = libc::malloc(out_len) as (*mut u8);

        let res = extern_def::assemble(e_arch, ins.as_ptr(), out_arr, &mut out_len);
        if res == 0 {
            Some(slice::from_raw_parts(out_arr, out_len as usize).to_vec())
        } else {
            None
        }
    }
}

#[test]
fn test_assemble() {
    assert_eq!(assemble(Arch::X86, "int3").unwrap(), [0xcc]);
}
